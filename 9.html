<!DOCTYPE html>

<html>
    <head>
        <link rel="stylesheet" href="../LearnHtml/css/nav.css">
        <link rel="stylesheet" href="../LearnHtml/css/style3.css">
    </head>

    <body>
       <hr>
       <nav>
           <ul>
            <li><a href="index.html">Главная страница</a></li>
            <li><a href="page.html">первая страница</a></li>
            <li><a href="1.html">Работа с изображениями на HTML</a></li>
            <li><a href="2.html">Работа с таблицами на HTML</a></li>
            <li><a href="3.html">Практика на основные HTML теги</a></li>
            <li><a href="4.html">Основы работы с языком CSS</a></li>
            <li><a href="8.html">Селекторы</a></li>
            <li><a href="9.html">Займемся ссылками на CSS</a></li>
            <li><a href="new-page.html">Более лаконичное продолжение</a></li>
               <hr>
            <li><a href="7.html">Практическая страница с языком CSS</a></li>
            <li><a href="5.html">Практическая страница простейшего позиционирования</a></li>
            <li><a href="6.html">Практическое задание №2</a></li>
            <hr>
            <li><a href="Mypage.html">Моя страница</a></li>
            
          </ul>
       </nav>
<hr>






<div>
    <h1>Займемся ссылками на CSS</h1>
    <hr>
        <h2>Состояния ссылок на CSS</h2>    

        <p>Как вы могли заметить на всех сайтах ссылки имеют разный вид при наведении или например после того как вы ее поситили. Такой эффект можно сделать задавая ссылкам определенное поведение при помощи псевдоклассов. Существуют следующие псевдоклассы ссылок:</p>

        <p>:Hover - псевдокласс который задает поведение ссылки при наведении мышки</p>
        <p>:Link - псевдокласс который отвечает за повеедение непосещенной ссылки <a href="#" class="lnk">(стандартно это синий цвет)</a></p>
        <p>:visited - псевдокласс который отвечает за повеедение посещенной ссылки <a href="#" class="lnk">(стандартно это фиолетовый цвет)</a></p>
        <p>:active - псевдокласс который отвечает за повеедение ссылки на которую нажали, но не отпустили кнопку мыши <a href="#" class="lnk">(стандартно это красный цвет)</a></p>

            <div class="inblock">
                <p>Сделайте все ссылки во всех состояниях голубыми и неподчеркнутыми, а в состоянии :hover - красными и подчеркнутыми.</p>
                <ul class="test-menu">
                    <a href="Mypage.html"><li>Моя страница</li></a>
                    <a href="index.html"><li>Начальная страница</li></a>
                </ul>
            </div>

        <h2>Сложные селекторы с состояниями ссылок на CSS</h2>
            <p class="xmp">Все сложные селекторы, которые мы изучали ранее, можно применять и для ссылок.

                Давайте посмотрим на примере. Пусть наши ссылки находятся в блоке с заданным id:
            </p>
              <xmp>
                    <div id="block">
                        <a href="#">ссылка</a>
                        <a href="#">ссылка</a>
                        <a href="#">ссылка</a>
                    </div>
              </xmp>
              <xmp>
                Давайте зададим стили для ссылок из этого блока:
                
                #block a:link, #block a:visited {
                    color: red;
                }
                #block a:hover {
                    text-decoration: none;
                }

                Как правило, состояния link и visited не разделяют, 
                поэтому код можно упростить следующим образом:
                
                #block a {
                    color: red;
                }
                #block a:hover {
                    text-decoration: none;
                }
            </xmp>


<h1>Выборка по позиции элементов на CSS. Концевые элементы</h1>

<h2>псевдокласс :first-child</h2>

            <p>:first-child Выбирает первого потомка от родителя</p>

            
            <p>
                СИНТАКСИС:

                селектор:first-child {
    	
                }
            </p>

            <P>Пример</P>

         
                <p>
                    В данном примере мы сделаем красного цвета тот li, который является первым потомком своего родителя (первым внутри ol):
                    
                </p>
                <xmp>
                <ol>
                    <li>list item</li> //Только этот элемент будет красным
                    <li>list item</li>
                    <li>list item</li>
                    <li>list item</li>
                    <li>list item</li>
                </ol>
            </xmp>

                <p class="xmp">
                    li:first-child {
                    color: red;
                    }
                </p>
       

<h2>псевдокласс :last-child</h2>

<p>:last-child Выбирает последнего потомка от родителя. Тоесть противоположен :first-child</p>

            
            <xmp>
                СИНТАКСИС:

                селектор:last-child {
    	
                }
            </xmp>

            <P>Пример</P>

            
                <p>В данном примере мы сделаем красного цвета тот li, который является первым потомком своего родителя (первым внутри ol):</p>
                <xmp>
                <ol>
                    <li>list item</li> 
                    <li>list item</li>
                    <li>list item</li>
                    <li>list item</li>
                    <li>list item</li> //Только этот элемент будет красным
                </ol>


                li:last-child {
                color: red;
                }
            </xmp>

<h2>Псевдокласс nth-child</h2>

<p>Псевдокласс nth-chaild выбирает элементы по указанному условию</p>

<xmp>
    селектор:nth-child(число | odd | even | выражение) {
	
    }

    Пример:

    li:nth-child(4) {
        color: red;
    }
</xmp>

<p>
    <table>
        <tr>
            <td>Значение</td>
            <td>Описание</td>
        </tr>


        <tr>
            <td>Число</td>
            <td>Положительное число начиная с 1. задает номер эл-та к которому обращаемся</td>
        </tr>

        <tr>
            <td>odd</td>
            <td>Нечетные числа</td>
        </tr>
           
        <tr>
            <td>even</td>
            <td>Четные числа</td>
        </tr>

        <tr>
            <td>Выражение</td>
            <td>
                Можно составлять специальные выражения с буквой n, которая обозначает все целые числа от нуля (не от единицы!) до бесконечности. Так, 2n - значит все четные числа (начиная со второго).
                <hr>
                Как это понять? Подставляем в n последовательно числа от 0 и так далее: если n = 0, то 2n даст 0 - такого элемента нет (нумерация элементов с 1!), если n = 1, то 2n даст 2 - второй элемент, если n = 2, 2n дает 4 - четвертый элемент. Если написать 3n - это будет каждый третий элемент (начиная с третьего!), и так далее.
            </td>
        </tr>
        
    </table>


</p>

<p>Выбор диапазона элементов осуществляется следующим образом.</p>

<xmp>
    <ol>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    </ol>




    li:nth-child(n+7):nth-child(-n+14) {
    	color: red;
    }
</xmp>


<h2>Заданые элементы с конца. Псевдокласс nth-last-child</h2>

<p>Псевдокласс nth-last-child выбирает элемент, который является n-ным потомком родителя, отсчитывая с конца. Ведет себя аналогично nth-child, только отсчет ведется с конца.</p>


<xmp>
    селектор:nth-last-child(число | odd | even | выражение) {
	
    }

    Пример:

    li:nth-last-child(4) {
        color: red;
    }
</xmp>



<table>
    <tr>
        <td>Значение</td>
        <td>Описание</td>
    </tr>


    <tr>
        <td>Число</td>
        <td>Положительное число начиная с 1. задает номер эл-та к которому обращаемся</td>
    </tr>

    <tr>
        <td>odd</td>
        <td>Нечетные числа</td>
    </tr>
       
    <tr>
        <td>even</td>
        <td>Четные числа</td>
    </tr>

    <tr>
        <td>Выражение</td>
        <td>
            Можно составлять специальные выражения с буквой n, которая обозначает все целые числа от нуля (не от единицы!) до бесконечности. Так, 2n - значит все четные числа (начиная со второго).
            <hr>
            Как это понять? Подставляем в n последовательно числа от 0 и так далее: если n = 0, то 2n даст 0 - такого элемента нет (нумерация элементов с 1!), если n = 1, то 2n даст 2 - второй элемент, если n = 2, 2n дает 4 - четвертый элемент. Если написать 3n - это будет каждый третий элемент (начиная с третьего!), и так далее.
        </td>
    </tr>
    
</table>


<h2>Единственные потомки. Псевдокласс only-child</h2>

<p>Псевдокласс :only-child выбирает элемент, который является единственным потомком родителя.</p>

<xmp>
    селектор:only-child(число | odd | even | выражение) {
	
    }

    Пример:

    ul
        li list item li  //Будет применено только к данному элементу.
    ul
    
    ul
         li list item li //Не применится в этом теги ul есть и другие.
         li list item li
         li list item li
    ul


    li:only-child {
        color: red;
    }


</xmp>

<h2>Пустые элементы. Псевдокласс empty</h2>

<p>Псевдокласс Empty задает параметры для пустых элемонтов, то есть тех которые не содержат текст. Стоит учесть что такой тег как HR создающий горизонтальную черту является пустым, следовательно задав параметры для всех пустых тегов на странице этот тег попадет под влияние так как он пустой</p>

<p class="pust"></p>

<h3>Существует еще одно свойство empty-cells.</h3>

<p>Свойство empty-cells указывает браузеру как отображать фон и границу пустых ячеек td или ячеек th HTML таблицы: показывать или нет.

    Ячейка считается пустой в следующих случаях: нет вообще никаких символов, в ячейке содержится только пробел (один или несколько), перевод строки или символ табуляции, либо свойство visibility установлено как hidden.
    
    Чтобы сделать ячейку не пустой, но при этом без видимого текста, используют следующий прием: в ячейку записывают неразрывный пробел &nbsp;.
    
    Свойство не работает, если задан border-collapse в значении collapse.</p>


<xmp>
    селектор {
    	empty-cells: show | hide;

        show - фон и границы показаны (значение по умолчанию)
        hide - фон и границы скрыты
    }
</xmp>

<table>
	<tr>
		<td>cell</td>
		<td></td>
		<td>cell</td>
	</tr>
	<tr>
		<td></td>
		<td>cell</td>
		<td></td>
	</tr>
	<tr>
		<td>cell</td>
		<td>cell</td>
		<td>cell</td>
	</tr>
</table>

<h1>Выборка по позиции и типу элемнтов. First-of-type и last-of-type</h1>

<h2>First-of-type</h2>

<p>Псевдокласс first-of-type выбирает элемент, который является первым потомком родителя заданного типа. То есть, если написать h2:first-of-type - найдется первый h2 в родителе (в отличии от first-child, который найдет только тот h2, который стоит самым первым в родителе).</p>

<xmp>
    селектор:first-of-type {
    	
    }
</xmp>

<div class="fot indiv">
	<h2>заголовок</h2>
	<p>абзац</p>
	
	<h2>заголовок</h2>
	<p>абзац</p>
	
	<h2>заголовок</h2>
	<p>абзац</p>
</div>

<p>
    здесь используется 
    
</p>

<xmp>
    .fot p:first-of-type {
    
        color: red;
      
      } 
</xmp>

<div class="fots indiv">
	<h2>заголовок</h2>
	<p>абзац</p>
	
	<h2>заголовок</h2>
	<p>абзац</p>
	
	<h2>заголовок</h2>
	<p>абзац</p>
</div>

<p>
    А здесь используется 
    
</p>

<xmp>
    .fots p:first-child {

        color: red;
      
      }
</xmp>

<p>Что касается last-of-type он делает тоже самое. Только с конца, то есть с нижнего элемента ищет. В отличии от last-child он найдет первый стоящий с конца элемент а не тот который стоит прям самым самым последним. last-child выбирает самый последний элемент если его нет то он его и не выбирает, а вот last-of-type выбирает первы попавшийся искомый элемент.</p>

<xmp>
<div>
    <h2>заголовок</h2>
    <p>абзац</p>
    
    <h2>заголовок</h2>
    <p>абзац</p>
    
<h2>заголовок</h2> //Этот элемент первый попавшийся искомый. last-of-type
<p>абзац</p> //Этот элемент первый с конца. last-child

</div>
    
    h2:last-of-type {
    	color: red;
    }
    
</xmp>



<h2>Псевдокласс nth-of-type</h2>

<p>Псевдокласс nth-of-type выбирает элемент который является n-ым потомком заданого типа.</p>
<p>То есть. если написать h2:nth-of-type(4) - найдется 4-ый h2 в родителе (В отличии от nth-child который находит только h2 который является 4-ым элементос внутри родителя)</p>

<p>Синтаксис точно такой же как и в придидущих селекторах</p>

<xmp>
    селектор {
    	селектор:nth-of-type(число | odd | even | выражение);
    }
    
</xmp>


<P><span class="attent">Внимание!!!</span> Селектор nth-last-of-type делает тоже самое что и nth-of-type только с конца</P>

<h2>Единственный потомок указанного типа only-of-type. Находит единственный тег потомок.</h2>

<p>Например:</p>


<xmp>
    <div>
        <h2>заголовок</h2> //Выбран будет только этот тег. так как он единственный у данного родителя.
        <p>абзац</p>
        <p>абзац</p>
        <p>абзац</p>
    </div>
    <div>
        <h2>заголовок</h2>
        <p>абзац</p>
        
        <h2>заголовок</h2>
        <p>абзац</p>
        <p>абзац</p>
    </div>


    div {
        border: 1px dashed black;
        padding: 15px;
        margin-bottom: 10px;
    }
    h2:only-of-type {
        color: red;
    }
</xmp>

<h2>Селектор отрицания. :not</h2>

<p>Псевдокласс :not задает отрицание. Например: p:not(.last) выберет все абзацы в которых нет класса last. Вложенные not не работают.</p>


<p>Синтаксис данного селектора простой</p>

<xmp>
    селектор:not(отрицание) {
    	
    }

    p:not(.last){

        color: red;
    }
    
    <div>
        <p class="last">Черный</p>// Этот  тег имеет класс last что является отрицанием.
        <p>красный</p> 
        <p>Красный</p>
    </div>
</xmp>

<p>Напишите селектор, который выберет все li, кроме первой.</p>

<xmp>
    li:not(first-child){
        color:red;
    }
    
</xmp>

<p>Напишите селектор, который выберет все li, кроме первой и последней</p>

<ul class="test1">
	<li>1</li>
	<li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
	<li>6</li>
	<li>7</li>
	<li>8</li>
	<li>9</li>
</ul>

<xmp>
    .test1 li:not(:first-child, :last-child) {
        color:red;
      }
</xmp>


<h1>Установка цвета фона страницы и элемнтов на ней.</h1>

<p>изменять цвет текста мы научились. А что касается фона? ведь на дургих сайтах есть даже фоновые картинки. Так вот давайте сделаем так же круто как и на других сайтах. научимся красить не только текст но и фон элементов и сайта в целом.</p>

<p>За цвет фона отвечает селектор background-color, он принимает  теже парметры что и селектор color</p>

<p>для примера давайте зальем блок сделаем оранжевым</p>

<xmp>
    div {
        background-color: orange;
    }
    
</xmp>

<p>Собственно вот и все, теперь фон будет у вес div элементов оранжевым</p>

<p>Хотелось бы напомнить о таком псевдоклассе как :empty, который задает параметры для пустых элементов, так вот, чтобы сделать пустой квадрат нужного нам цвета достачтоно к нужному селектору добавить данный псевдокласс :empty</p>

<p>Давайте сделаем такой круг для пример</p>

<br>
<div class="pustcircul"></div>
<br>


<h2>Основы работы с границами.</h2>

<p>Чтобы задать параметры для границы элемента есть два способа.</p>

<p>Длинный способ:</p>


<xmp>
    #elem {
    	border-width: 3px;    /* толщина 3px */
    	border-style: solid;  /* в виде линии */
    	border-color: red;    /* красный цвет */
    	width: 300px;
    	height: 100px;
    }
    
</xmp>

<p>Короткий способ:</p>

<xmp>
    #elem {
       border: 1px solid red; // толщина линии _ тип линии _ цвет линии
    }
</xmp>

<p>Оба варианта работают одинаково, так же если во <span class="attent">упрощенном варианте</span>, не указать толщину линии она изначально равна 1px, если не указать цвет то он по стандарту black (черный). Сокращение BORDER точно такое же как и для текста FONT</p>

<p>А что если нам нужна линия только слева или например справа? Для этого достаточно указать после border один из следующим вариантов</p>

<xmp>
    -left
    -right
    -bottom
    -top
    
</xmp>

<p>Например:</p>

<xmp>
    #elem {
    	width: 300px;
    	height: 100px;
    	border-left: 1px solid red;
    }
</xmp>
<br>
<div class="snoska">типы линый:
    <p class="dotted">dotted</p>
    <p class="dashed">dashed</p>
    <p class="ridge">ridge</p>
    <p class="double">double</p>
</div>

<p>Как вы могли заметить у блока с типами линий есть две линии двух разных типов, да такое тоже можно сделать</p>

<h2>Скругление углов элементов.</h2>

<p>Да да прям как у яблочной компании. Все галаденько и  элегантно.</p>

<p>Чтобы добиться такой элегантности не требуется многого, достаточно к селектору применить свойство border-radius, и все будет как нам того и хотелось. Вот пример:</p>

<br>

<div class="bradius"></div>

<br>

<xmp>
    <div class="bradius"></div>
    
    
    .bradius:empty {
        width: 150px;
        border-radius: 10px;
      }
    
</xmp>


<h2>Разные скругления для разных углов CSS</h2>

<p>Свойство border-radius может принимать не только одно значение, но и два, три или четыре. Каждое значение будет задавать скругление для своего угла. Давайте посмотрим более подробно.</p>

<h3>4 значения</h3>
<p>
    Если задано четыре значения, то первое значение задает скругление для верхнего левого угла, второе - для верхнего правого, третье - для нижнего правого угла, а четвертое - для нижнего левого угла:
</p>


<h3>2 значения</h3>
<p>
    Если задано два значения, то первое значение задает скругление для верхнего правого и нижнего левого углов, второе - для верхнего левого и нижнего правого:
</p>


<h3>3 значения</h3>
<p>
    Если задано три значения, то первое значение задает скругление для верхнего левого угла, второе - одновременно для верхнего правого и нижнего левого, а третье - для нижнего правого угла.
</p>

<p>Border-radius принимает значения не только в PX но так же и в %, которые отсчитываются от соотношения сторон</p>

<p>если мы сделаем прямоугольник и зададит ему border-radius 50%, то он станет овалом, если для квадрата сделать тоже самое, то будет круг</p>

<a class="stops" href="https://code.mu/ru/markup/book/prime/decoration/background-images/#:~:text=%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D1%81%20%D1%84%D0%BE%D0%BD%D0%BE%D0%B2%D1%8B%D0%BC%D0%B8,%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%20%D1%84%D0%BE%D0%BD%D0%B0"><p class="stops"> Остановился на данном месте</p></a>

<h1>Свойство background-image</h1>
<p>Свойство background-image задет фоновоую картинку элементу. По умолчанию картинка замостит своими копиями весь блок, однако, это свойство можно отменить с помощью свойства background-repeat</p>


<p>Синтаксис:</p>



<xmp>
    селектор {
    	background-image: url(путь к картинке);
    }


</xmp>

<table>
    <tr>
        <th>Значение</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>url</td>
        <td>Путь к файлу с картинкой. Название картинки может быть в двойных кавычках, одинарных и вообще без кавычек.</td>
    </tr>
    <tr>
        <td>none</td>
        <td>Отменяет фоновую кртинку для элемента</td>
    </tr>

    
</table>


<h1>Свойство background-repeat</h1>
<p>Свойство background-repeat задает каким образом повторять фоновую картинку. По умолчанию она заполняет своими копиями все пространство элемента</p>

<p>Синтаксис:</p>



<xmp>
    селектор {
        background-repeat: no-repeat | repeat | repeat-x | repeat-y | space | round;
    }


</xmp>

<table>
    <tr>
        <th>Значение</th>
        <th>Описание</th>
    </tr>

    <tr>
        <td>no-repeat</td>
        <td>Повторение выключено совсем</td>
    </tr>

    <tr>
        <td>repeat-x</td>
        <td>Повторяем только по оси Х</td>
    </tr>

    <tr>
        <td>repeat-y</td>
        <td>Повторяем только по оси Y</td>
    </tr>

    <tr>
        <td>repeat</td>
        <td>Повторяем картинку по X и Y (как по умолчанию)</td>
    </tr>
    
    <tr>
        <td>space</td>
        <td>Картинка повторяется столько раз чтобы полность заполнить пространство. если это не удается то между картинками добавляется пространство</td>
    </tr>

    <tr>
        <td>round</td>
        <td>Картинка повтаряется так чтобы в области поместилось целое число рисуноков. если этого не удается то рисунки масштабируются</td>
    </tr>

    
</table>

<h1>Коротко о других свойствах фоновых картинок</h1>


<h3>background-position</h3>
       <p>
            Свойство background-position задает местоположение фоновой картинки элемента. Местоположение можно задавать с помощью любых единиц для размеров. Первое значение обозначает отступ слева, второе - отступ сверху.
    
            Можно также задавать положение ключевыми словами. В этом случае порядок значений не важен. Ключевые слова для вертикали: top, center, bottom. Ключевые слова по горизонтали: left, center, right.
            
       </p>

      <p>
           Чтобы разместить картинку ключевым словом, нужно указать одно значение для вертикали и одно для горизонтали. К примеру, если указать значение top right, то картинка станет сверху справа.
    
    Порядок слов неважен: можно написать top right, а можно - right top. Если есть ключевое слово center - его можно опускать. Например, top center, все равно что просто top. А center center все равно что просто center.
      </p>

<h3>background-size </h3>
    <p>Свойство background-size задает размер картинки фона. Значением свойства служат любые единицы для размеров, либо ключевые слова auto, cover или contain.</p>
    <p>Синтаксис:</p>
<xmp>
    
        селектор {
            background-size: значение;
        }
    
        
</xmp>

<table>
    <tr>
        <th>Значение</th>
        <th>Описание</th>
    </tr>

    <tr>
        <td>auto</td>
        <td>Размер фона равен реальному размеру картинки используемой для него. если задан размер для конкретной стороны то картинка будет отмасштабирована так чтобы не испортить пропорции.</td>
    </tr>

    <tr>
        <td>Cover</td>
        <td>Масштабирует картинку так чтобы заполнить ей все пространство с сохранение пропорций. Картинка будет стараться поместиться целиком, но это не всегда будет получаться, поэтому какая-то ее часть будет обрезаться. Блок всегда будет покрыт картинкой целиком.</td>
    </tr>

    <tr>
        <td>Contain</td>
        <td>масштабируются с сохранением пропорций, при этом всегда будет заполнять блок по вертикали ИЛИ горизонтали.  Блок в общем случае будет покрыт картинкой не целиком (зато картинка всегда будет видна вся, хоть и в уменьшенном варианте).</td>
    </tr>

</table>



<h3>background-attachment</h3> 
<p>Свойство background-attachment задает каким образом прокручивать фоновую картинку элемента: вместе с текстом или текст будет скользить по картинке.</p>

<table>
    <tr>
        <th>Значение</th>
        <th>Описание</th>
    </tr>

    <tr>
        <td>fixed</td>
        <td>Картинка фона будет неподвижной, а текст будет скользить по ней.</td>
    </tr>

    <tr>
        <td>scroll</td>
        <td>Картинка фона будет прокручиваться вместе с текстом.</td>
    </tr>

    <tr>
        <td>local</td>
        <td>Фон фиксируется с учетом поведения элемента. Если элемент имеет прокрутку, то фон будет прокручиваться вместе с содержимым, но фон выходящий за рамки элемента остается на месте.</td>
    </tr>

</table>

<h3>background-clip</h3> 
<p>Свойство background-clip задает как фоновая заливка или фоновая картинка будет размещаться относительно элемента: часть фона будет залазить под границу, фон не будет залазить под границу или фон будет размещаться только над содержимым элемента (то есть padding отодвинет фон).</p>

<table>
    <tr>
        <th>Значение</th>
        <th>Описание</th>
    </tr>

    <tr>
        <td>border-box</td>
        <td>Фон залезет под границу</td>
    </tr>

    <tr>
        <td>padding-box</td>
        <td>Фон не будет залезать под границу </td>
    </tr>

    <tr>
        <td>content-box</td>
        <td>Фон будет только над содержимым</td>
    </tr>

</table>

<div class="testbgcontent1">
  
</div>

<h3>background-origin</h3> 

<p>Свойство background-origin задает то, как фоновая картинка (именно картинка, не заливка) будет размещаться относительно элемента: часть картинки фона будет залазить под границу, фон не будет залазить под границу или фон будет размещаться только над содержимым элемента (то есть padding отодвинет фон).</p>

<table>
    <tr>
        <th>Значение</th>
        <th>Описание</th>
    </tr>

    <tr>
        <td>border-box</td>
        <td>Фоновая картинка залезет под границу</td>
    </tr>

    <tr>
        <td>padding-box</td>
        <td>Фоновая картинка не будет залезать под границу </td>
    </tr>

    <tr>
        <td>content-box</td>
        <td>Фоновая картинка будет только над содержимым</td>
    </tr>

</table>

<div class="testbgcontent2">
   
</div>


<h3>background</h3>
<p>
    Свойство background задает одновременно все свойства фона: background-attachment, background-color, background-image, background-position, background-repeat, background-size, background-origin, background-clip.
    
    Порядок свойств значения не имеет. Ненужные свойства можно опускать - в этом случае оно примет значение по умолчанию. Свойства background-position и background-size задаются через слеш и в этом случае порядок имеет значение (сначала позиция, потом размер).
    
    Также свойство background принимает значение none, соответствующее отсутствию фона.
</p>

<div class="testbgcontent3">
   
</div>


<h1>Внешний вид маркеров списков ul и ol</h1>

<h2>Вид списка UL</h2>
<div>
    <p>Изменить внешний маркеров списков можно с помощью свойства list-style-type. Оно может приимать следующие начения: Square, circle, disc, none</p>
    <table>
        <tr>
            <th>Значение</th>
            <th>Описание</th>
        </tr>
    
        <tr>
            <td>Square</td>
            <td>Маркеры в виде квадратов</td>
        </tr>
    
        <tr>
            <td>circle</td>
            <td>Маркеры в виде кругов с пустым центром</td>
        </tr>
    
        <tr>
            <td>disc</td>
            <td>Маркеры в виде точек, стандартный вид по умолчанию</td>
        </tr>

        <tr>
            <td>none</td>
            <td>Маркеры отсутствию</td>
        </tr>
    
    </table>
</div>


<h2>Вид списка OL</h2>
<div>
    <p>Изменить внешний маркеров списков можно с помощью свойства list-style-type. Оно может принимать следующие начения: lower-roman, upper-roman, lower-alpha, upper-alpha, lower-greek, decimal-leading-zero</p>
    <table>
        <tr>
            <th>Значение</th>
            <th>Описание</th>
        </tr>
    
        <tr>
            <td>lower-roman</td>
            <td>Маркеры в виде римских цифр</td>
        </tr>
    
        <tr>
            <td>upper-roman</td>
            <td>Маркеры в виде заглавных римских цифр</td>
        </tr>
    
        <tr>
            <td>lower-alpha</td>
            <td>Маркеры в виде латинских букв</td>
        </tr>

        <tr>
            <td>upper-alpha</td>
            <td>Маркеры в виде больших латинских букв</td>
        </tr>
        <tr>
            <td>lower-greek</td>
            <td>Маркеры в виде малые греческие буквы</td>
        </tr>
        <tr>
            <td>decimal-leading-zero</td>
            <td>Маркеры в виде чисел, но с нулем впереди для чисел меньше 10</td>
        </tr>
    </table>
</div>

<h1>Работа с отступами margin</h1>

<div>
    <p>Свойство margin - задает отступы между элементами на сайте, то есть внешние отступы, те что снаружи элементов.</p>
    <p>Для примера если сделать два элемента без отступов по margin, то они слипнуться и мы будем наблюдать двойную линию, чтобы подобного избежать наи и нужен отступ по margin</p>
    <p>Margin так же как и многие другие свойства можно указывать по нескольким стронам верх, низ, право, лево или же через упращенное свойство задать все 4 стороны.</p>

    <xmp>
        #child {
            margin-top:    10px; /* сверху */
            margin-right:  20px; /* справа */
            margin-bottom: 30px; /* снизу */
            margin-left:   40px; /* слева */
            
            height: 100px;
            border: 1px solid green;
        }
        ------------------------------------------
        p {
            margin: 10px 20px  40px  30px; //4 значения
            margin: верх право  низ  лево;
        }
        ------------------------------------------
        p {
            margin: 10px         20px; //2 значения
            margin: верх и низ   право и лево;
        }
        ------------------------------------------
        p {
            margin: 10px      20px         40px; //3 значения
            margin: верх   право и лево    низ 
        }
    </xmp>

    <p>По 4 значениям отступы задаются в следующем порядке верх, право, низ, лево</p>
    <p>По 2 значениям отступы задаются в следующем порядке верх и низ, право и лево</p>
    <p>По 3 значениям отступы задаются в следующем порядке верх, право и лево, низ</p>
    
</div>

<h1>Работа с отступами padding</h1>

<div>
    <p>Свойство padding делает тоже самое что и margin. но отступ образуется внутри элемента относительно границ, простыми словами Padding - отталкивает (делает отступ от границ) содержимое внутрь, а margin - отталкивает (делает отступ от границ) снаружи </p>
</div>

<p class="attent">Внимение!!!</p>

<p>При использовании padding следует учитывать тот факт? что он разширяtт элемент. Это означает, что если мы зададим элементу значение width: 100px;  и при этом же зададим ему padding: 10px;  то его итоговая ширена будет не 100рх а 110рх.</p>

<p>Этот нюанс следует учитывать так же и при создании границ у элемента, так как граница тоже расширяет элемент эквивалентно своему значению. Из чего следует сделать вывод, что если мы к предидущемо примеру width: 100px; padding: 10px; добавим еще и border: 5px solid red; , то итоговая ширена элемента будет уже не 110рх а целых 115рх.</p>

<h2>Убираем влияние отступов и границы на расширение. box-sizing</h2>


    <p>Чтобы отступы и границы не расширяли элемент есть спецаильное свойство box-sizing которому присваивают значение border-box</p>

<p class="attent">Внимение!!!</p>

<a href="https://code.mu/ru/markup/book/prime/block-model/block-elements/#:~:text=%D0%9E%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8%20%D0%B1%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D1%85%20%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2%20%D0%B2%20CSS"><h1>Особенности блочных элементов в CSS</h1></a>


<h2>Рассмотрим элементы которые определяются как блочные при отображении</р>

<h3>Ширена и высота блочных элементов.</h3>

<p>Блочным элементвам можно здать строго высоту и ширену, при этом они будет соответсвовать указаным параметрам.</p>
<p>Если блочному элементу не указать ширену, то он займет всю доступную ширену страницы</p>
<p>Если блочному эементу не задать высоту то она формируется содержимым. То есть, когда ширена переполнится и пойдет новая строка, высота автоматически увеличится чтобы содержимое находилось внутри. В тоже время если элемент будет пуст, то мы увидим две линии слипшиейся в одну, так как содержимое не растягивает его (содержимого то нет)</p>
<p>Блочные элементы расположенные рядом, автоматически располагаются друг под другом, то есть каждый следующий блочный элемент начинается с новой строки</p>

<h2>Рассмотрим элементы которые определяются как строчные при отображении</h2>

<h3>Ширена и высота строчных элементов</h3>

<p>Если строчному элементу задать ширену и высоту, то они просто не сработают. Высота и ширена строчного элемента формируется исходя из содержимого</p>
<p>Несколько строчных элементов расположеных рядом, будут выводится друг за другов в ряд как с троке. Следует так же учитывать, что если в HTML коде между словами текста есть пробелы, то при их выводе, между строчными элементами образуются отступы.</p>

<xmp>
    <span>text</span>
    <span>text</span>
    <span>text</span>

</xmp>

<span>text</span>
<span>text</span>
<span>text</span>


<xmp>
    <span>text</span><span>text</span><span>text</span>

</xmp>

<span>text</span><span>text</span><span>text</span>

<h2>Тестовые задания на определение к какому типу относится элемент</h2>

<p>Определите, к какой блочной модели относятся теги p</p>
    <p>Короткий текст ответ блочный</p>
<p>Определите, к какой блочной модели относятся теги b.</p>
    <b>Короткий текст ответ строчный</b>
<p>Определите, к какой блочной модели относятся теги h2</p>
    <h2>Короткий текст ответ блочный</h2>
<p>Определите, к какой блочной модели относятся теги h3</p>
    <h3>Короткий текст ответ строчный</h3>
<p>Определите, к какой блочной модели относятся теги i.</p>
    <i>Короткий текст строчный</i>
<p>Определите, к какой блочной модели относятся теги a</p>
    <a>Короткий текст строчный</a>

<h1>Работа со свойством display. Смена блочных на строчные и обратно.</h1>

<p>Как понятно из названия темы, мы можем сменить тип поведения элементов например со строчного на блочный, в таком случае строчные элементы будут вести себя как блочные.</p>

<p>Как мы помним span это строчный элемент. Однако</p>

  
<span class="spanblock">text</span>
<span class="spanblock">text</span>
<span class="spanblock">text</span>

<xmp>
    
    <span class="spanblock">text</span>
    <span class="spanblock">text</span>
    <span class="spanblock">text</span>
    
    .spanblock {
        display: block;
      }
    
</xmp>

<h1>Особенности строчно-блочных элементов в CSS</h1>

<p>Рассмотрим теги, которые при отображении на экране являются строчно-блочными. Строчно-блочные элементы сочетают особенности блочных и строчных элементов. Из таких элементов нам известен только один и это img, но на его примере тяжело будет понять всю суть строчно-блочных элементов, для этого мы сделаем span строчно-блочным (inline-block)</p>

<p>Ширена и высота у строчно блочных элементов задается так же как и у блочных элементов. То есть строго указать ширену и высоту можно и она будет работать по указаным парамметрам.</p>
<p>А вот если ширену не указать, то она формируется от содержимого, как у строчных элементов, тоесть содержимое растягивает блок по мере необходимости. Точно так же происходит и с высотой строчно-блочных элементов.</p>
<p>Строчно-блочные расположенные рядом, будут выстраиваться в ряд подобно строчным элементам.</p>


<h1>Выравнивание БЛОЧНЫХ элементов</h1>

<p>Свойство margin используется не только для задания отступов, но так же и для центрирования БЛОЧНЫХ элементов, для этого правый и левый отступ следует задать в значение auto. margin: 0px auto. </p>

<p class="attent">Следует отметить, что этот способ действует только на БЛОЧНЫЕ элементы, которым задана ширена, а так же только по горизонтали.</p>

<p>Значение auto для margin на самом деле может не только центрировать. Фактически это значение позволяет рассчитать отступ автоматически и сделать его максимально возможным. Когда мы ставим auto для левого и правого отступа - элемент центрируется.
Можно, однако, поставить только левый отступ. В этом случае элемент получит максимально возможный отступ слева и займет крайнее правое положение.</p>
<p>При этом не запрещено указать отступ справа для данного элемента, что просто не даст ем прилипнуть к правому краю слишком сильно.</p>

<a href="https://code.mu/ru/markup/book/prime/block-model/inline-alignment/#:~:text=%D0%92%D1%8B%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%81%D1%82%D1%80%D0%BE%D1%87%D0%BD%D1%8B%D1%85%20%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2"><h1>Выравнивание СТРОЧНЫХ элементов</h1></a>

<p>Строчные элементы выравниваются не так как БЛОЧНЫЕ. ДЛя выравнивания строчных элементов используется свойство text-align, которое присваивается родительскому элементу. То есть, если родителю задано text-align: centerl; то все потомки будут позиционироваться по центру.</p>
<p>Выравнивание строчных элемнтов делается с помощью использования общепринятых слов left, right, center.</p>

<h1>Выравнивание строчно-блочных элементов</h1>

<p>Строчно-блочные элементы выравниваются так же как и строчные - с помощью text-align в нужном значении, заданном для родителя</p>

<h1>Пора перейти на новую страницу так что полетели</h1>


</div>
    </body>
</html>
