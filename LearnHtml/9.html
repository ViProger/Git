<!DOCTYPE html>

<html>
    <head>
        <link rel="stylesheet" href="css/style3.css">
    </head>

    <body>
       <hr>
       <ul>
        <li><a href="index.html">Главная страница</a></li>
        <li><a href="page.html">первая страница</a></li>
        <li><a href="1.html">Работа с изображениями на HTML</a></li>
        <li><a href="2.html">Работа с таблицами на HTML</a></li>
        <li>
          <a href="3.html">Практика на основные HTML теги</a>
        </li>
        <li><a href="4.html">Основы работы с языком CSS</a></li>
        <li><a href="8.html">Селекторы</a></li>
        <li><a href="9.html">Займемся ссылками на CSS</a></li>


        <hr>
        <li><a href="7.html">Практическая страница с языком CSS</a></li>
        <li>
          <a href="5.html">Практическая страница простейшего позиционирования</a>
        </li>
        <li><a href="6.html">Практическое задание №2</a></li>
        <hr>
        <li><a href="Mypage.html">Моя страница</a></li>
        
      </ul>
<hr>



фывфывфывфывфыв


<div>
    <h1>Займемся ссылками на CSS</h1>
    <hr>
        <h2>Состояния ссылок на CSS</h2>    

        <p>Как вы могли заметить на всех сайтах ссылки имеют разный вид при наведении или например после того как вы ее поситили. Такой эффект можно сделать задавая ссылкам определенное поведение при помощи псевдоклассов. Существуют следующие псевдоклассы ссылок:</p>

        <p>:Hover - псевдокласс который задает поведение ссылки при наведении мышки</p>
        <p>:Link - псевдокласс который отвечает за повеедение непосещенной ссылки <a href="#" class="lnk">(стандартно это синий цвет)</a></p>
        <p>:visited - псевдокласс который отвечает за повеедение посещенной ссылки <a href="#" class="lnk">(стандартно это фиолетовый цвет)</a></p>
        <p>:active - псевдокласс который отвечает за повеедение ссылки на которую нажали, но не отпустили кнопку мыши <a href="#" class="lnk">(стандартно это красный цвет)</a></p>

            <div class="inblock">
                <p>Сделайте все ссылки во всех состояниях голубыми и неподчеркнутыми, а в состоянии :hover - красными и подчеркнутыми.</p>
                <ul class="test-menu">
                    <a href="Mypage.html"><li>Моя страница</li></a>
                    <a href="index.html"><li>Начальная страница</li></a>
                </ul>
            </div>

        <h2>Сложные селекторы с состояниями ссылок на CSS</h2>
            <p class="xmp">Все сложные селекторы, которые мы изучали ранее, можно применять и для ссылок.

                Давайте посмотрим на примере. Пусть наши ссылки находятся в блоке с заданным id:
            </p>
              <xmp>
                    <div id="block">
                        <a href="#">ссылка</a>
                        <a href="#">ссылка</a>
                        <a href="#">ссылка</a>
                    </div>
              </xmp>
              <xmp>
                Давайте зададим стили для ссылок из этого блока:
                
                #block a:link, #block a:visited {
                    color: red;
                }
                #block a:hover {
                    text-decoration: none;
                }

                Как правило, состояния link и visited не разделяют, 
                поэтому код можно упростить следующим образом:
                
                #block a {
                    color: red;
                }
                #block a:hover {
                    text-decoration: none;
                }
            </xmp>


<h1>Выборка по позиции элементов на CSS. Концевые элементы</h1>

<h2>псевдокласс :first-child</h2>

            <p>:first-child Выбирает первого потомка от родителя</p>

            
            <p>
                СИНТАКСИС:

                селектор:first-child {
    	
                }
            </p>

            <P>Пример</P>

         
                <p>
                    В данном примере мы сделаем красного цвета тот li, который является первым потомком своего родителя (первым внутри ol):
                    
                </p>
                <xmp>
                <ol>
                    <li>list item</li> //Только этот элемент будет красным
                    <li>list item</li>
                    <li>list item</li>
                    <li>list item</li>
                    <li>list item</li>
                </ol>
            </xmp>

                <p class="xmp">
                    li:first-child {
                    color: red;
                    }
                </p>
       

<h2>псевдокласс :last-child</h2>

<p>:last-child Выбирает последнего потомка от родителя. Тоесть противоположен :first-child</p>

            
            <xmp>
                СИНТАКСИС:

                селектор:last-child {
    	
                }
            </xmp>

            <P>Пример</P>

            
                <p>В данном примере мы сделаем красного цвета тот li, который является первым потомком своего родителя (первым внутри ol):</p>
                <xmp>
                <ol>
                    <li>list item</li> 
                    <li>list item</li>
                    <li>list item</li>
                    <li>list item</li>
                    <li>list item</li> //Только этот элемент будет красным
                </ol>


                li:last-child {
                color: red;
                }
            </xmp>

<h2>Псевдокласс nth-child</h2>

<p>Псевдокласс nth-chaild выбирает элементы по указанному условию</p>

<xmp>
    селектор:nth-child(число | odd | even | выражение) {
	
    }

    Пример:

    li:nth-child(4) {
        color: red;
    }
</xmp>

<p>
    <table>
        <tr>
            <td>Значение</td>
            <td>Описание</td>
        </tr>


        <tr>
            <td>Число</td>
            <td>Положительное число начиная с 1. задает номер эл-та к которому обращаемся</td>
        </tr>

        <tr>
            <td>odd</td>
            <td>Нечетные числа</td>
        </tr>
           
        <tr>
            <td>even</td>
            <td>Четные числа</td>
        </tr>

        <tr>
            <td>Выражение</td>
            <td>
                Можно составлять специальные выражения с буквой n, которая обозначает все целые числа от нуля (не от единицы!) до бесконечности. Так, 2n - значит все четные числа (начиная со второго).
                <hr>
                Как это понять? Подставляем в n последовательно числа от 0 и так далее: если n = 0, то 2n даст 0 - такого элемента нет (нумерация элементов с 1!), если n = 1, то 2n даст 2 - второй элемент, если n = 2, 2n дает 4 - четвертый элемент. Если написать 3n - это будет каждый третий элемент (начиная с третьего!), и так далее.
            </td>
        </tr>
        
    </table>


</p>

<p>Выбор диапазона элементов осуществляется следующим образом.</p>

<xmp>
    <ol>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    	<li>list item</li>
    </ol>




    li:nth-child(n+7):nth-child(-n+14) {
    	color: red;
    }
</xmp>


<h2>Заданые элементы с конца. Псевдокласс nth-last-child</h2>

<p>Псевдокласс nth-last-child выбирает элемент, который является n-ным потомком родителя, отсчитывая с конца. Ведет себя аналогично nth-child, только отсчет ведется с конца.</p>


<xmp>
    селектор:nth-last-child(число | odd | even | выражение) {
	
    }

    Пример:

    li:nth-last-child(4) {
        color: red;
    }
</xmp>



<table>
    <tr>
        <td>Значение</td>
        <td>Описание</td>
    </tr>


    <tr>
        <td>Число</td>
        <td>Положительное число начиная с 1. задает номер эл-та к которому обращаемся</td>
    </tr>

    <tr>
        <td>odd</td>
        <td>Нечетные числа</td>
    </tr>
       
    <tr>
        <td>even</td>
        <td>Четные числа</td>
    </tr>

    <tr>
        <td>Выражение</td>
        <td>
            Можно составлять специальные выражения с буквой n, которая обозначает все целые числа от нуля (не от единицы!) до бесконечности. Так, 2n - значит все четные числа (начиная со второго).
            <hr>
            Как это понять? Подставляем в n последовательно числа от 0 и так далее: если n = 0, то 2n даст 0 - такого элемента нет (нумерация элементов с 1!), если n = 1, то 2n даст 2 - второй элемент, если n = 2, 2n дает 4 - четвертый элемент. Если написать 3n - это будет каждый третий элемент (начиная с третьего!), и так далее.
        </td>
    </tr>
    
</table>


<h2>Единственные потомки. Псевдокласс only-child</h2>

<p>Псевдокласс :only-child выбирает элемент, который является единственным потомком родителя.</p>

<xmp>
    селектор:only-child(число | odd | even | выражение) {
	
    }

    Пример:

    ul
        li list item li  //Будет применено только к данному элементу.
    ul
    
    ul
         li list item li //Не применится в этом теги ul есть и другие.
         li list item li
         li list item li
    ul


    li:only-child {
        color: red;
    }


</xmp>

<h2>Пустые элементы. Псевдокласс empty</h2>

<p>Псевдокласс Empty задает параметры для пустых элемонтов, то есть тех которые не содержат текст. Стоит учесть что такой тег как HR создающий горизонтальную черту является пустым, следовательно задав параметры для всех пустых тегов на странице этот тег попадет под влияние так как он пустой</p>

<p class="pust"></p>

<h3>Существует еще одно свойство empty-cells.</h3>

<p>Свойство empty-cells указывает браузеру как отображать фон и границу пустых ячеек td или ячеек th HTML таблицы: показывать или нет.

    Ячейка считается пустой в следующих случаях: нет вообще никаких символов, в ячейке содержится только пробел (один или несколько), перевод строки или символ табуляции, либо свойство visibility установлено как hidden.
    
    Чтобы сделать ячейку не пустой, но при этом без видимого текста, используют следующий прием: в ячейку записывают неразрывный пробел &nbsp;.
    
    Свойство не работает, если задан border-collapse в значении collapse.</p>


<xmp>
    селектор {
    	empty-cells: show | hide;

        show - фон и границы показаны (значение по умолчанию)
        hide - фон и границы скрыты
    }
</xmp>

<table>
	<tr>
		<td>cell</td>
		<td></td>
		<td>cell</td>
	</tr>
	<tr>
		<td></td>
		<td>cell</td>
		<td></td>
	</tr>
	<tr>
		<td>cell</td>
		<td>cell</td>
		<td>cell</td>
	</tr>
</table>

<h1>Выборка по позиции и типу элемнтов. First-of-type и last-of-type</h1>

<h2>First-of-type</h2>

<p>Псевдокласс first-of-type выбирает элемент, который является первым потомком родителя заданного типа. То есть, если написать h2:first-of-type - найдется первый h2 в родителе (в отличии от first-child, который найдет только тот h2, который стоит самым первым в родителе).</p>

<xmp>
    селектор:first-of-type {
    	
    }
</xmp>

<div class="fot indiv">
	<h2>заголовок</h2>
	<p>абзац</p>
	
	<h2>заголовок</h2>
	<p>абзац</p>
	
	<h2>заголовок</h2>
	<p>абзац</p>
</div>

<p>
    здесь используется 
    
</p>

<xmp>
    .fot p:first-of-type {
    
        color: red;
      
      } 
</xmp>

<div class="fots indiv">
	<h2>заголовок</h2>
	<p>абзац</p>
	
	<h2>заголовок</h2>
	<p>абзац</p>
	
	<h2>заголовок</h2>
	<p>абзац</p>
</div>

<p>
    А здесь используется 
    
</p>

<xmp>
    .fots p:first-child {

        color: red;
      
      }
</xmp>

<p>Что касается last-of-type он делает тоже самое. Только с конца, то есть с нижнего элемента ищет. В отличии от last-child он найдет первый стоящий с конца элемент а не тот который стоит прям самым самым последним. last-child выбирает самый последний элемент если его нет то он его и не выбирает, а вот last-of-type выбирает первы попавшийся искомый элемент.</p>

<xmp>
<div>
    <h2>заголовок</h2>
    <p>абзац</p>
    
    <h2>заголовок</h2>
    <p>абзац</p>
    
<h2>заголовок</h2> //Этот элемент первый попавшийся искомый. last-of-type
<p>абзац</p> //Этот элемент первый с конца. last-child

</div>
    
    h2:last-of-type {
    	color: red;
    }
    
</xmp>



<h2>Псевдокласс nth-of-type</h2>

<p>Псевдокласс nth-of-type выбирает элемент который является n-ым потомком заданого типа.</p>
<p>То есть. если написать h2:nth-of-type(4) - найдется 4-ый h2 в родителе (В отличии от nth-child который находит только h2 который является 4-ым элементос внутри родителя)</p>

<p>Синтаксис точно такой же как и в придидущих селекторах</p>

<xmp>
    селектор {
    	селектор:nth-of-type(число | odd | even | выражение);
    }
    
</xmp>


<P><span class="attent">Внимание!!!</span> Селектор nth-last-of-type делает тоже самое что и nth-of-type только с конца</P>

<h2>Единственный потомок указанного типа only-of-type. Находит единственный тег потомок.</h2>

<p>Например:</p>


<xmp>
    <div>
        <h2>заголовок</h2> //Выбран будет только этот тег. так как он единственный у данного родителя.
        <p>абзац</p>
        <p>абзац</p>
        <p>абзац</p>
    </div>
    <div>
        <h2>заголовок</h2>
        <p>абзац</p>
        
        <h2>заголовок</h2>
        <p>абзац</p>
        <p>абзац</p>
    </div>


    div {
        border: 1px dashed black;
        padding: 15px;
        margin-bottom: 10px;
    }
    h2:only-of-type {
        color: red;
    }
</xmp>

<h2>Селектор отрицания. :not</h2>

<p>Псевдокласс :not задает отрицание. Например: p:not(.last) выберет все абзацы в которых нет класса last. Вложенные not не работают.</p>


<p>Синтаксис данного селектора простой</p>

<xmp>
    селектор:not(отрицание) {
    	
    }

    p:not(.last){

        color: red;
    }
    
    <div>
        <p class="last">Черный</p>// Этот  тег имеет класс last что является отрицанием.
        <p>красный</p> 
        <p>Красный</p>
    </div>
</xmp>

<p>Напишите селектор, который выберет все li, кроме первой.</p>

<xmp>
    li:not(first-child){
        color:red;
    }
    
</xmp>

<p>Напишите селектор, который выберет все li, кроме первой и последней</p>

<ul class="test1">
	<li>1</li>
	<li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
	<li>6</li>
	<li>7</li>
	<li>8</li>
	<li>9</li>
</ul>

<xmp>
    .test1 li:not(:first-child, :last-child) {
        color:red;
      }
</xmp>


<h1>Установка цвета фона страницы и элемнтов на ней.</h1>

<p>изменять цвет текста мы научились. А что касается фона? ведь на дургих сайтах есть даже фоновые картинки. Так вот давайте сделаем так же круто как и на других сайтах. научимся красить не только текст но и фон элементов и сайта в целом.</p>

<p>За цвет фона отвечает селектор background-color, он принимает  теже парметры что и селектор color</p>

<p>для примера давайте зальем блок сделаем оранжевым</p>

<xmp>
    div {
        background-color: orange;
    }
    
</xmp>

<p>Собственно вот и все, теперь фон будет у вес div элементов оранжевым</p>

<p>Хотелось бы напомнить о таком псевдоклассе как :empty, который задает параметры для пустых элементов, так вот, чтобы сделать пустой квадрат нужного нам цвета достачтоно к нужному селектору добавить данный псевдокласс :empty</p>

<p>Давайте сделаем такой круг для пример</p>

<br>
<div class="pustcircul"></div>
<br>


<h2>Основы работы с границами.</h2>

<p>Чтобы задать параметры для границы элемента есть два способа.</p>

<p>Длинный способ:</p>


<xmp>
    #elem {
    	border-width: 3px;    /* толщина 3px */
    	border-style: solid;  /* в виде линии */
    	border-color: red;    /* красный цвет */
    	width: 300px;
    	height: 100px;
    }
    
</xmp>

<p>Короткий способ:</p>

<xmp>
    #elem {
       border: 1px solid red; // толщина линии _ тип линии _ цвет линии
    }
</xmp>

<p>Оба варианта работают одинаково, так же если во <span class="attent">упрощенном варианте</span>, не указать толщину линии она изначально равна 1px, если не указать цвет то он по стандарту black (черный). Сокращение BORDER точно такое же как и для текста FONT</p>

<p>А что если нам нужна линия только слева или например справа? Для этого достаточно указать после border один из следующим вариантов</p>

<xmp>
    -left
    -right
    -bottom
    -top
    
</xmp>

<p>Например:</p>

<xmp>
    #elem {
    	width: 300px;
    	height: 100px;
    	border-left: 1px solid red;
    }
</xmp>
<br>
<div class="snoska">типы линый:
    <p class="dotted">dotted</p>
    <p class="dashed">dashed</p>
    <p class="ridge">ridge</p>
    <p class="double">double</p>
</div>

<p>Как вы могли заметить у блока с типами линий есть две линии двух разных типов, да такое тоже можно сделать</p>

<h2>Скругление углов элементов.</h2>

<p>Да да прям как у яблочной компании. Все галаденько и  элегантно.</p>

<p>Чтобы добиться такой элегантности не требуется многого, достаточно к селектору применить свойство border-radius, и все будет как нам того и хотелось. Вот пример:</p>

<br>

<div class="bradius"></div>

<br>

<xmp>
    <div class="bradius"></div>
    
    
    .bradius:empty {
        width: 150px;
        border-radius: 10px;
      }
    
</xmp>


<h2>Разные скругления для разных углов CSS</h2>

<p>Свойство border-radius может принимать не только одно значение, но и два, три или четыре. Каждое значение будет задавать скругление для своего угла. Давайте посмотрим более подробно.</p>

<h3>4 значения</h3>
<p>
    Если задано четыре значения, то первое значение задает скругление для верхнего левого угла, второе - для верхнего правого, третье - для нижнего правого угла, а четвертое - для нижнего левого угла:
</p>


<h3>2 значения</h3>
<p>
    Если задано два значения, то первое значение задает скругление для верхнего правого и нижнего левого углов, второе - для верхнего левого и нижнего правого:
</p>


<h3>3 значения</h3>
<p>
    Если задано три значения, то первое значение задает скругление для верхнего левого угла, второе - одновременно для верхнего правого и нижнего левого, а третье - для нижнего правого угла.
</p>

<p>Border-radius принимает значения не только в PX но так же и в %, которые отсчитываются от соотношения сторон</p>

<p>если мы сделаем прямоугольник и зададит ему border-radius 50%, то он станет овалом, если для квадрата сделать тоже самое, то будет круг</p>



<a class="stops" href="https://code.mu/ru/markup/book/prime/decoration/background-images/#:~:text=%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D1%81%20%D1%84%D0%BE%D0%BD%D0%BE%D0%B2%D1%8B%D0%BC%D0%B8,%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%20%D1%84%D0%BE%D0%BD%D0%B0"><p class="stops"> Остановился на данном месте</p></a>




















</div>
    </body>
</html>
